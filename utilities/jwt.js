/**
 * Generate a JWT for the user's account information.
 */
export async function generateJWT(sub, type, env) {
  const header = {
    alg: "HS256",
    typ: "JWT"
  };
  const now = Math.floor(Date.now() / 1000);
  const payload = {
    sub: sub,
    type: type,
    iat: now,
    exp: now + parseInt(env.ACCESS_TOKEN_EXPIRY_SECONDS || "900", 10),
    iss: "packsyncr"
  };

  function base64UrlEncode(obj) {
    return btoa(JSON.stringify(obj))
    .replace(/=/g, "")
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
  }

  const encodedHeader = base64UrlEncode(header);
  const encodePayload = base64UrlEncode(payload);
  const data = `${encodedHeader}.${encodePayload}`;

  const key = await crypto.subtle.importKey(
    "raw",
    new TextEncoder().encode(env.JWT_SECRET),
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );

  const signatureBuffer = await crypto.subtle.sign(
    "HMAC",
    key,
    new TextEncoder().encode(data)
  );

  const signature = btoa(String.fromCharCode(...new Uint8Array(signatureBuffer)))
  .replace(/=/g, "")
  .replace(/\+/g, "-")
  .replace(/\//g, "_");

  return `${data}.${signature}`;
}

/**
* Verify a JWT generated by generateAccessToken.
* Returns decoded payload on success, throws on failure.
*/
export async function verifyJWT(token, type, env) {
if (!token || typeof token !== "string") {
  throw new Error("missing_token");
}

const parts = token.split(".");
if (parts.length !== 3) {
  throw new Error("invalid_format");
}

const [encodedHeader, encodedPayload, encodedSignature] = parts;

// Recreate the unsigned data
const data = `${encodedHeader}.${encodedPayload}`;

// Convert Base64URL to ArrayBuffer
function base64UrlToUint8Array(str) {
  str = str.replace(/-/g, "+").replace(/_/g, "/");
  while (str.length % 4 !== 0) str += "=";
  return Uint8Array.from(atob(str), c => c.charCodeAt(0));
}

const signatureBytes = base64UrlToUint8Array(encodedSignature);

// Import key for verification
const key = await crypto.subtle.importKey(
  "raw",
  new TextEncoder().encode(env.JWT_SECRET),
  { name: "HMAC", hash: "SHA-256" },
  false,
  ["verify"]
);

// Verify signature
const isValidSignature = await crypto.subtle.verify(
  "HMAC",
  key,
  signatureBytes,
  new TextEncoder().encode(data)
);

if (!isValidSignature) {
  throw new Error("invalid_signature");
}

// Decode payload
const payloadJson = atob(encodedPayload.replace(/-/g, "+").replace(/_/g, "/")
.padEnd(encodedPayload.length + (4 - encodedPayload.length % 4) % 4, "="));

let payload;
try {
  payload = JSON.parse(payloadJson);
} catch {
  throw new Error("invalid_payload");
}

// Validate claims
const now = Math.floor(Date.now() / 1000);

if (payload.exp && now >= payload.exp) {
  throw new Error("token_expired");
}

if (payload.iss !== "packsyncr") {
  throw new Error("invalid_issuer");
}

if (payload.type !== type) {
  throw new Error("invalid_token_type");
}

if (!payload.sub) {
  throw new Error("missing_sub");
}

return payload;
}

/**
* Extracts and verifies an access JWT from the request.
* Returns the decoded payload on success.
* Throws an error on failure.
*/
export async function getAccessTokenPayload(request, env) {
  const auth = request.headers.get("Authorization") || "";

  if (!auth.startsWith("Bearer ")) {
      throw new Error("missing_bearer_token");
  }

  const token = auth.slice("Bearer ".length).trim();

  return verifyJWT(token, "access", env);
}
